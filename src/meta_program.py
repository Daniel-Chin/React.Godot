from __future__ import annotations

from typing import *
import os
from os import path
from time import sleep
from threading import Thread, Lock, Semaphore
from io import StringIO
from enum import Enum

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileModifiedEvent
from tqdm import tqdm

QUEUE_MAX = 8

class Stage(Enum):
    FIRST_LINE = 0
    WAITING_FOR_FORMAL_PARAM = 1
    AT_FORMAL_PARAM = 2
    WAITING_FOR_PROP_DIFF = 3
    AT_PROP_DIFF = 4
    TAIL = 5

class Prop:
    def __init__(self, type_: str, name: str) -> None:
        self.type = type_
        self.name = name
    
    def asFormalParam(self):
        return f'{self.type} {self.name}_'
    
    def __str__(self):
        return self.name

PRIVATE = 'private '
def validate(filename: str):
    buf = StringIO()
    props: List[Prop] = []
    file_modified = False
    with open(filename, 'r', encoding='utf-8') as f:
        stage: Stage = Stage.FIRST_LINE
        do_expect_prop = False
        for line in f:
            if stage is Stage.FIRST_LINE:
                if not line.startswith('// META_PROGRAM: react.godot script.'):
                    return
                buf.write(line)
                stage = Stage.WAITING_FOR_FORMAL_PARAM
            elif stage in (
                Stage.WAITING_FOR_FORMAL_PARAM, 
                Stage.WAITING_FOR_PROP_DIFF, 
                Stage.TAIL, 
            ):
                buf.write(line)
                line_stripped = line.strip()
                if do_expect_prop:
                    do_expect_prop = False
                    assert line_stripped.startswith(PRIVATE)
                    line_stripped = line_stripped[len(PRIVATE):]
                    type_, name = line_stripped.rstrip(';').split(' ')
                    props.append(Prop(type_, name))
                    continue
                if line_stripped == "// Don't edit! Generated by meta programming.":
                    stage = Stage(stage.value + 1)
                elif line_stripped == '[ReactProp]':
                    do_expect_prop = True
            elif stage is Stage.AT_FORMAL_PARAM:
                lineBuf = StringIO()
                lineBuf.write(' ' * 8)
                lineBuf.write(', '.join([x.asFormalParam() for x in props]))
                lineBuf.write('\n')
                lineBuf.seek(0)
                new_line = lineBuf.read()
                file_modified = file_modified or (new_line != line)
                buf.write(new_line)
                stage = Stage(stage.value + 1)
            elif stage is Stage.AT_PROP_DIFF:
                lineBuf = StringIO()
                lineBuf.write(' ' * 8)
                for prop in props:
                    lineBuf.write(f'if (! {prop}.Equals({prop}_)) {{ {prop} = {prop}_; need_react = true; }} ')
                lineBuf.write('\n')
                lineBuf.seek(0)
                new_line = lineBuf.read()
                file_modified = file_modified or (new_line != line)
                buf.write(new_line)
                stage = Stage(stage.value + 1)
    assert stage is Stage.TAIL
    if not file_modified:
        return
    buf.seek(0)
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(buf.read())

class Worker(Thread):
    def __init__(self, group: None = None, target: Callable[..., object] | None = None, name: str | None = None, args: Iterable[Any] = ..., kwargs: Mapping[str, Any] | None = None, *, daemon: bool | None = None) -> None:
        super().__init__(group, target, name, args, kwargs, daemon=daemon)
        self.todo: Set[str] = set()
        self.lock = Lock()
        self.barrier = Semaphore(QUEUE_MAX)
        for _ in range(QUEUE_MAX):
            self.barrier.acquire()
        self.do_stop = False
    
    def eat(self, filename: str):
        with self.lock:
            if filename not in self.todo:
                self.todo.add(filename)
                self.barrier.release()

    def run(self):
        while True:
            self.barrier.acquire()
            if self.do_stop:
                return
            sleep(.1)
            with self.lock:
                filename = self.todo.pop()
            print('Validating:', filename)
            validate(filename)
    
    def stop(self):
        self.do_stop = True
        self.barrier.release()

class FileModifiedHandler(FileSystemEventHandler):
    def __init__(self) -> None:
        super().__init__()
        self.worker = Worker()
        self.worker.start()

    def on_modified(self, event):
        if type(event) is not FileModifiedEvent:
            return
        print('Modified:', event.src_path)
        self.worker.eat(event.src_path)

def main():
    os.chdir(path.dirname(__file__))
    for filename in tqdm(os.listdir(), desc='Validating all'):
        validate(filename)
    fileModifiedHandler = FileModifiedHandler()
    observer = Observer()
    observer.schedule(fileModifiedHandler, '.', recursive=True)
    observer.start()
    print('Enter Ctrl+Z to quit.')
    print('Watchdog watching!')
    try:
        while True:
            input()
    except (KeyboardInterrupt, EOFError):
        pass
    finally:
        observer.stop()
        fileModifiedHandler.worker.stop()
        observer.join()
        fileModifiedHandler.worker.join()

main()
